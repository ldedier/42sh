When a process in a background job tries to read from its controlling terminal,
the process group is usually sent a SIGTTIN signal.
This normally causes all of the processes in that group to stop
(unless they handle the signal and donâ€™t stop themselves).
However, if the reading process is ignoring or blocking this signal,
then read fails with an EIO error instead.
-------------------------------------------------------------------------------
If user tries to close 42sh while there are jobs running
warn first time
second time send SIGHUP to all jobs
===================================================================
What to return in case of max job num exceeded.
(ERROR or STP_CMD_LINE)
Both these value corrupt the current prompt output.
===================================================================
Jobs, fg, bg options!
===================================================================
test when shell is running in bg
===================================================================
Signals are working properly with/without pipes.
Reworked bg, fg (Corrected the running status not being updated after calls to bg, fg.
Seperated signals handlers depending on phase (One for the shell, one for executing simple commands.
To do:
Rework the signal handling code (Test it then clean it up)
Handle the AND_OR nods when ampersand character is present.
Make sure the (jc_enable) condition is present when it needs to be.
Added the '%' character to the builtins.
Test how the shell as well as the jobs reacts to outside signaling (via kill).
builtin commands that end with &
non-interative shell with signals (./42sh < In then ctrl_z or ctrl_c)
TEST TEST TEST
===================================================================
sleep & (leaks)
42sh < in6 launched from within 42sh
===================================================================
 sleep 10 || ls then ctrl_z segfault cuz these need to be 2 seperate jobs
===================================================================
fg prints the job command as well